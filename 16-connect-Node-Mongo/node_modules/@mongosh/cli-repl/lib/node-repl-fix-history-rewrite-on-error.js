"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixNodeReplHistoryHandler = fixNodeReplHistoryHandler;
const stream_1 = require("stream");
function awaitNextPrompt(repl) {
    return new Promise((resolve) => {
        const original = repl.displayPrompt.bind(repl);
        repl.displayPrompt = function (...args) {
            repl.displayPrompt = original;
            resolve();
            return original(...args);
        };
    });
}
let replHasNodeBug;
async function detectReplNodeBug() {
    var _a, _b, _c;
    const { start: replStart } = require('repl');
    const input = new stream_1.PassThrough();
    const repl = replStart({
        input,
        output: new stream_1.PassThrough(),
        terminal: true,
        useGlobal: true,
        eval(evalCmd, context, file, cb) {
            try {
                cb(null, eval(evalCmd));
            }
            catch (e) {
                cb(e, null);
            }
        },
    });
    try {
        input.write('__mongoshInternal__ThisDoesNotExist\n');
        const nextPromptPromise = awaitNextPrompt(repl);
        input.write('42\n');
        await nextPromptPromise;
        const history = (_c = (_b = (_a = repl.historyManager) === null || _a === void 0 ? void 0 : _a.history) !== null && _b !== void 0 ? _b : repl === null || repl === void 0 ? void 0 : repl.history) !== null && _c !== void 0 ? _c : [];
        return history.length < 2;
    }
    finally {
        repl.close();
    }
}
function getAllOwnSymbols(obj) {
    const out = [];
    const seen = new Set();
    for (let cur = obj; cur !== null; cur = Object.getPrototypeOf(cur)) {
        for (const sym of Object.getOwnPropertySymbols(cur)) {
            if (!seen.has(sym)) {
                seen.add(sym);
                out.push(sym);
            }
        }
    }
    return out;
}
async function fixNodeReplHistoryHandler(repl) {
    replHasNodeBug !== null && replHasNodeBug !== void 0 ? replHasNodeBug : (replHasNodeBug = await detectReplNodeBug());
    if (!replHasNodeBug) {
        return;
    }
    const replSymbols = getAllOwnSymbols(repl);
    const kIsMultiline = replSymbols.find((s) => String(s).includes('(_isMultiline)'));
    const kAddHistory = replSymbols.find((s) => String(s).includes('(_addHistory)'));
    if (!kAddHistory || !kIsMultiline) {
        console.error('Node.js 24+ History bug detected but could not patch it.');
        return;
    }
    const replUnsafe = repl;
    Object.defineProperty(replUnsafe, kAddHistory, {
        value: function () {
            return this.historyManager.addHistory(this[kIsMultiline], false);
        }.bind(replUnsafe),
        writable: false,
        configurable: false,
    });
}
//# sourceMappingURL=node-repl-fix-history-rewrite-on-error.js.map